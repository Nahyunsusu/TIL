# 자료구조 : List, LinkedList, Stack, Queue

## 1. 리스트

가장 단순한 형태인 리스트 => List<T>
순차 자료구조 연결 자료구조의 차이점

List<string> list = new();

list.Add("De");

list.Insert(1, "Velo");

// 삭제
// 맨뒤의 데이터를 삭제할 때 o(1)
중간 데이터 삭제 O(n)

list.Remove
list.RemoveAt

// 검색

if(list.Contains("De"))
```csharp
using System;
using System.Collections.Generic;

class Program
{
    static void Main(string[] args)
    {
        List<Monster> list = new List<Monster>();

        list.Add(new Monster("Oak"));
        PrintList(list);

        Monster Slime = new Monster("Slime");
        list.Add(Slime);
        PrintList(list);

        list.Add(new Monster("Goblin"));
        PrintList(list);

        list.Insert(1, new Monster("Skull"));
        PrintList(list);

        static void PrintList(List<Monster> list)
        {
            foreach(Monster l in list)
            {
                Console.Write($"{l.name}\t");
            }

            Console.WriteLine("");
        }

        // 탐색
        Console.WriteLine(list[2].name);

        if(list.Contains(Slime))
        {
            Console.WriteLine("슬라임 찾았음");
        }

        // 삭제

        list.Remove(Slime);
        PrintList(list);

        list.RemoveAt(0);
        PrintList(list);
    }
}

public class Monster
{
    public string name { get; private set; }

        public Monster(string name)
    {
        this.name = name;
    }
}
```
```csharp
using System;
using System.Collections.Generic;

class Program
{
    static void Main(string[] args)
    {
        List<int> list = new List<int>();

        Random rand = new Random();

        for (int i = 0; i < 1000; i++)
        {
            list.Add(rand.Next(0, 3000));
        }

        for (int i = 0; i < list.Count; i++)
        {
            Console.Write(list[i]);
        }

        Console.WriteLine("");

        int findValue = 555;

        for(int i=0;i<list.Count;i++)
        {
            if (list[i] == findValue)
            {
                Console.WriteLine($"선형탐색 횟수 : {i}");
            }
        }

        Console.WriteLine(list.BinarySearch(findValue));

    }
}
```
# 링크드 리스트 LinkedList
```csharp
using System;
using System.Collections.Generic;

class Program
{
    static void Main(string[] args)
    {
        // AddFirst
        // AddLast
        // AddBefore
        // AddAfter
        // Remove(2);
        // RemoveFirst
        // RemoveLast

        LinkedList<int> list = new LinkedList<int>();

        LinkedListNode<int> node = list.AddFirst(1);
        PrintList(list);

        list.AddFirst(2); // [2][1]
        PrintList(list);

        list.AddFirst(3); // [3][2][1]
        PrintList(list);

        list.AddFirst(4); // [4][3][2][1]
        PrintList(list);

        list.AddLast(5); // [4][3][2][1][5]
        PrintList(list);

        list.AddBefore(node, 6);
        PrintList(list);

        list.AddAfter(node, 7);
        PrintList(list);

        list.Remove(7);
        PrintList(list);

        list.RemoveFirst();
        PrintList(list);

        list.RemoveLast();
        PrintList(list);

        Console.WriteLine($"list Count : {list.Count}");

        static void PrintList(LinkedList<int> list)
        {
            Console.Write("// ");

            foreach (int l in list)
            {
                Console.Write($"[{l}]");
            }
            Console.WriteLine("");
        }
    }
}
```
## Stack
```csharp
using System;
using System.Collections.Generic;

class Program
{
    static void Main(string[] args)
    {
        Stack<int> stack = new Stack<int>();

        stack.Push(1);
        stack.Push(2);
        stack.Push(3);

        Console.WriteLine(stack.Peek()); // 확인만

        foreach (int i in stack)
        {
            Console.WriteLine(i);
        }

        Console.WriteLine($"value = {stack.Pop()} / count = {stack.Count}");
        Console.WriteLine($"value = {stack.Pop()} / count = {stack.Count}");
        Console.WriteLine($"value = {stack.Pop()} / count = {stack.Count}");
    }
}

public class Command
{
    public int a;
}
```
## Queue
```csharp
using System;
using System.Collections.Generic;

class Program
{
    static void Main(string[] args)
    {
        Queue<Unit> Barracks = new();

        Barracks.Enqueue(new Unit("Marine"));
        Barracks.Enqueue(new Unit("Ghost"));
        Barracks.Enqueue(new Unit("Firebat"));
        Barracks.Enqueue(new Unit("Medic"));
        Barracks.Enqueue(new Unit("Marine"));


        Unit unit = Barracks.Dequeue();

        foreach(Unit u in Barracks)
        {
            Console.WriteLine($"{u.Name}\t");
        }
    }
}

public class Unit
{
    public string Name { get; private set; }

    public Unit(string name)
    {
        Name = name;
    }
}

```
 

# 스태틱 static

static 키워드는 프로그램이 시작되고 나서 종료될 때까지 할당이 해제되지 않으면서 사용할 때 사용한다. 게임 내에서 지속적으로 사용되는 누적 점수, 혹은 바뀌면 안되는 특정 설정치 등 단순 변수의 개념부터 클래스와 같은 참조 타입까지 선언이 가능하다. 이를 메서드에 붙인다면 프로그램 내에서 어디든 간편하게 호출할 수 있겠지만 주의할 점이 있다. static으로 선언되면 그 대상이 필요를 다 했슴에도 불구하고 메모리에 계속 상주해 있어 메모리 누수가 발생할 수 있다.

값 타입과 참조 타입은 사용이 끄나면 자동으로 할당해제 되지만 static은 할당해제 되지 않는다.
최초 호출되는 시점에 DATA영역에 할당된다.
프로그램 어디서나 호출된다.
```csharp
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

using Pratice;

public class Program
{
    static void Main(string[] args)
    {
        GameManager gm = new GameManager();

        SystemUtil.AddPlayer();
        SystemUtil.AddPlayer();

        SystemUtil.RemovePlayer();

        Console.WriteLine(GameManager.PlayerCount);
    }
}

public class GameManager
{
    private static int _playerCount;

    public static int PlayerCount
    {
        get => _playerCount;
        set => _playerCount = value;
    }

    public bool IsPlaying { get; set; }

    // static으로 선언된 생성자는 static으로 선언된 필드나 메서드만 사용할 수 있음
    static GameManager()
    {
        _playerCount = 0;
        Console.WriteLine("GameManager static Constructor");
        Console.WriteLine($"Player Count : {PlayerCount}");
    }
    public GameManager()
    {
        Console.WriteLine("GameManager Constructor");
    }
}

// static으로 선언된 클래스
public static class SystemUtil
{
    public static void AddPlayer()
    {
        GameManager.PlayerCount++;
        Console.WriteLine("Add Player");
    }

    public static void RemovePlayer()
    {
        GameManager.PlayerCount--;
        Console.WriteLine("Remove Player");
    }
}   
```