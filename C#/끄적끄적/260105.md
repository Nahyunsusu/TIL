# QuickSort
```csharp
using System;
using System.Collections.Generic;
using System.Runtime.Intrinsics.X86;

class Program
{
    static void Main(string[] args)
    {
        List<int> list = new List<int>();

        list.Add(7);
        list.Add(3);
        list.Add(9);
        list.Add(1);
        list.Add(5);
        list.Add(8);
        list.Add(2);

        QuickSort(list, 0, list.Count -1);

        for(int i=0;i<list.Count;i++)
        {
            Console.Write($"{list[i]} \t");
        }
    }

    static void QuickSort(List<int> list, int left, int right)
    {
        if(left >= right)
            return;

        int pivot = Partition(list, left, right);

        QuickSort(list, left, pivot - 1);
        QuickSort(list, pivot + 1, right);
    }


    static int Partition(List<int> list, int left, int right)
    {
        int pivot = list[right];
        int i = left - 1;

        // 리스트 내부에서 pivot보다 작은 값들을 왼쪽으로
        for (int j = left; j < right; j++)
        {
            if (list[j] < pivot)
            {
                i++;
                Swap(list, i, j);
            }
        }

        // pivot을 작은 값 바로 다음 영역으로 이동시키고 고정
        int pivotIndex = i + 1;
        Swap(list, pivotIndex, right);

        return pivotIndex;
    }

    static void Swap(List<int> list, int a, int b)
    {
        int temp = list[a];
        list[a] = list[b];
        list[b] = temp;
    }

}
```
# MergeSort
```csharp
using System;
using System.Collections.Generic;
using System.Runtime.Intrinsics.X86;

class Program
{
    static void Main(string[] args)
    {
        List<int> list = new List<int>();

        list.Add(5);
        list.Add(2);
        list.Add(8);
        list.Add(3);
        list.Add(1);
        list.Add(6);
        list.Add(4);
        list.Add(7);

        MergeSort(list, 0, list.Count-1);
        
        for(int i=0;i<list.Count;i++)
        {
            Console.Write($"{list[i]}\t");
        }
    }

    static void MergeSort(List<int> list, int left, int right)
    {
        if (left >= right) 
            return;

        int center = (left + right) / 2;

        MergeSort(list, left, center);
        MergeSort(list, center + 1, right);

        Merge(list, left, center, right);
    }

    static void Merge(List<int> list, int left, int center, int right)
    {
        int[] temp = new int[right - left + 1];

        int leftIndex = left;
        int rightIndex = center + 1;
        int tempIndex = 0;         // temp에서 사용할 인덱스

        while (leftIndex <= center && rightIndex <= right)
        {
            // 불안정 정렬 [2a][1][2b][3] => [1][2b][2a][3]
            // 안정 정렬 [2a][1][2b][3] => [1][2a][2b][3]

            if (list[leftIndex] <= list[rightIndex])
            {
                temp[tempIndex] = list[leftIndex];
                leftIndex++;
            }
            else
            {
                temp[tempIndex] = list[rightIndex];
                rightIndex++;
            }
            tempIndex++;

        }

        // 왼쪽 범위에 남은 값이 있다면?
        while (leftIndex <= center)
        {
            temp[tempIndex] = list[leftIndex];
            leftIndex++;
            tempIndex++;
        }

        // 오른쪽 범위에 남은 값이 있다면?
        while (rightIndex <= right)
        {
            temp[tempIndex] = list[rightIndex];
            rightIndex++;
            tempIndex++;
        }

        Console.Write($"Merge ({left}~{center}) & ({center + 1}~{right}) => ");
        for (int i = 0; i < temp.Length; i++)
        {
            Console.Write(temp[i] + " ");
        }
        Console.WriteLine();

        for (int t = 0; t < temp.Length; t++)
        {
            list[left + t] = temp[t];
        }
    }
}

```
# DFS, BFS
```csharp
using System;
using System.Collections.Generic;

public class MatrixGraph
{
    private readonly bool[,] matrix;
    private int _vertextCount;
        static void Main(string[] args)
    {
        // 7개의 노드를 가진 이진 트리 생성 (높이 2)
        // 노드 번호: 0 (루트), 1~2 (자식), 3~6 (손자)
        MatrixGraph tree = new MatrixGraph(7);

        // 이진 트리 형태로 엣지 연결
        //          0
        //        /   \
        //       1     2
        //      / \   / \
        //     3   4 5   6
        tree.AddEdge(0, 1);
        tree.AddEdge(0, 2);
        tree.AddEdge(1, 3);
        tree.AddEdge(1, 4);
        tree.AddEdge(2, 5);
        tree.AddEdge(2, 6);

        Console.WriteLine("BFS 탐색 순서 (0번 노드 시작):");
        List<int> bfsResult = tree.DFS(0);
        Console.WriteLine(string.Join(" -> ", bfsResult));
    }

    public MatrixGraph(int vertextCount)
    {
        _vertextCount = vertextCount;
        matrix = new bool[vertextCount, vertextCount];
    }

    public void AddEdge(int from, int to)
    {
        matrix[from, to] = true;
        matrix[to, from] = true;
    }

    public List<int> QueueBFS(int start)
    {
        List<int> path = new List<int>();
        bool[] isVisited = new bool[_vertextCount];
        Queue<int> queue = new Queue<int>();

        isVisited[start] = true;
        queue.Enqueue(start);

        while (queue.Count > 0)
        {
            int current = queue.Dequeue();
            path.Add(current);

            for (int to = 0; to < _vertextCount; to++)
            {
                if (matrix[current, to] && !isVisited[to])
                {
                    isVisited[to] = true;
                    queue.Enqueue(to);
                }
            }
        }
        return path;
    }
    public List<int> StackDFS(int start)
    {
        List<int> path = new List<int>();
        bool[] isVisited = new bool[_vertextCount];
        Stack<int> queue = new Stack<int>();

        isVisited[start] = true;
        queue.Push(start);

        while (queue.Count > 0)
        {
            int current = queue.Pop();
            path.Add(current);

            for (int to = 0; to < _vertextCount; to++)
            {
                if (matrix[current, to] && !isVisited[to])
                {
                    isVisited[to] = true;
                    queue.Push(to);
                }
            }
        }
        return path;
    }

    public List<int> DFS(int start)
    {
        List<int> path = new List<int>();

        bool[] visited = new bool[_vertextCount];

        InternalDFS(start, visited, path);

        return path;
    }

    public void InternalDFS(int current, bool[] visited, List<int> path)
    {
        visited[current] = true;
        path.Add(current);

        for(int to = 0; to <_vertextCount; to++)
        {
            if (matrix[current, to] && !visited[to])
            {
                InternalDFS(to, visited, path);
            }
        }
    }
}
```
