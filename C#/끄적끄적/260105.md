# QuickSort
```csharp
using System;
using System.Collections.Generic;
using System.Runtime.Intrinsics.X86;

class Program
{
    static void Main(string[] args)
    {
        List<int> list = new List<int>();

        list.Add(7);
        list.Add(3);
        list.Add(9);
        list.Add(1);
        list.Add(5);
        list.Add(8);
        list.Add(2);

        QuickSort(list, 0, list.Count -1);

        for(int i=0;i<list.Count;i++)
        {
            Console.Write($"{list[i]} \t");
        }
    }

    static void QuickSort(List<int> list, int left, int right)
    {
        if(left >= right)
            return;

        int pivot = Partition(list, left, right);

        QuickSort(list, left, pivot - 1);
        QuickSort(list, pivot + 1, right);
    }


    static int Partition(List<int> list, int left, int right)
    {
        int pivot = list[right];
        int i = left - 1;

        // 리스트 내부에서 pivot보다 작은 값들을 왼쪽으로
        for (int j = left; j < right; j++)
        {
            if (list[j] < pivot)
            {
                i++;
                Swap(list, i, j);
            }
        }

        // pivot을 작은 값 바로 다음 영역으로 이동시키고 고정
        int pivotIndex = i + 1;
        Swap(list, pivotIndex, right);

        return pivotIndex;
    }

    static void Swap(List<int> list, int a, int b)
    {
        int temp = list[a];
        list[a] = list[b];
        list[b] = temp;
    }

}
```
# MergeSort
```csharp
using System;
using System.Collections.Generic;
using System.Runtime.Intrinsics.X86;

class Program
{
    static void Main(string[] args)
    {
        List<int> list = new List<int>();

        list.Add(5);
        list.Add(2);
        list.Add(8);
        list.Add(3);
        list.Add(1);
        list.Add(6);
        list.Add(4);
        list.Add(7);

        MergeSort(list, 0, list.Count-1);
        
        for(int i=0;i<list.Count;i++)
        {
            Console.Write($"{list[i]}\t");
        }
    }

    static void MergeSort(List<int> list, int left, int right)
    {
        if (left >= right) 
            return;

        int center = (left + right) / 2;

        MergeSort(list, left, center);
        MergeSort(list, center + 1, right);

        Merge(list, left, center, right);
    }

    static void Merge(List<int> list, int left, int center, int right)
    {
        int[] temp = new int[right - left + 1];

        int leftIndex = left;
        int rightIndex = center + 1;
        int tempIndex = 0;         // temp에서 사용할 인덱스

        while (leftIndex <= center && rightIndex <= right)
        {
            // 불안정 정렬 [2a][1][2b][3] => [1][2b][2a][3]
            // 안정 정렬 [2a][1][2b][3] => [1][2a][2b][3]

            if (list[leftIndex] <= list[rightIndex])
            {
                temp[tempIndex] = list[leftIndex];
                leftIndex++;
            }
            else
            {
                temp[tempIndex] = list[rightIndex];
                rightIndex++;
            }
            tempIndex++;

        }

        // 왼쪽 범위에 남은 값이 있다면?
        while (leftIndex <= center)
        {
            temp[tempIndex] = list[leftIndex];
            leftIndex++;
            tempIndex++;
        }

        // 오른쪽 범위에 남은 값이 있다면?
        while (rightIndex <= right)
        {
            temp[tempIndex] = list[rightIndex];
            rightIndex++;
            tempIndex++;
        }

        Console.Write($"Merge ({left}~{center}) & ({center + 1}~{right}) => ");
        for (int i = 0; i < temp.Length; i++)
        {
            Console.Write(temp[i] + " ");
        }
        Console.WriteLine();

        for (int t = 0; t < temp.Length; t++)
        {
            list[left + t] = temp[t];
        }
    }
}

```
# DFS, BFS
```csharp
using System;
using System.Collections.Generic;

public class MatrixGraph
{
    private readonly bool[,] matrix;
    private int _vertextCount;
        static void Main(string[] args)
    {
        // 7개의 노드를 가진 이진 트리 생성 (높이 2)
        // 노드 번호: 0 (루트), 1~2 (자식), 3~6 (손자)
        MatrixGraph tree = new MatrixGraph(7);

        // 이진 트리 형태로 엣지 연결
        //          0
        //        /   \
        //       1     2
        //      / \   / \
        //     3   4 5   6
        tree.AddEdge(0, 1);
        tree.AddEdge(0, 2);
        tree.AddEdge(1, 3);
        tree.AddEdge(1, 4);
        tree.AddEdge(2, 5);
        tree.AddEdge(2, 6);

        Console.WriteLine("BFS 탐색 순서 (0번 노드 시작):");
        List<int> bfsResult = tree.DFS(0);
        Console.WriteLine(string.Join(" -> ", bfsResult));
    }

    public MatrixGraph(int vertextCount)
    {
        _vertextCount = vertextCount;
        matrix = new bool[vertextCount, vertextCount];
    }

    public void AddEdge(int from, int to)
    {
        matrix[from, to] = true;
        matrix[to, from] = true;
    }

    public List<int> QueueBFS(int start)
    {
        List<int> path = new List<int>();
        bool[] isVisited = new bool[_vertextCount];
        Queue<int> queue = new Queue<int>();

        isVisited[start] = true;
        queue.Enqueue(start);

        while (queue.Count > 0)
        {
            int current = queue.Dequeue();
            path.Add(current);

            for (int to = 0; to < _vertextCount; to++)
            {
                if (matrix[current, to] && !isVisited[to])
                {
                    isVisited[to] = true;
                    queue.Enqueue(to);
                }
            }
        }
        return path;
    }
    public List<int> StackDFS(int start)
    {
        List<int> path = new List<int>();
        bool[] isVisited = new bool[_vertextCount];
        Stack<int> queue = new Stack<int>();

        isVisited[start] = true;
        queue.Push(start);

        while (queue.Count > 0)
        {
            int current = queue.Pop();
            path.Add(current);

            for (int to = 0; to < _vertextCount; to++)
            {
                if (matrix[current, to] && !isVisited[to])
                {
                    isVisited[to] = true;
                    queue.Push(to);
                }
            }
        }
        return path;
    }

    public List<int> DFS(int start)
    {
        List<int> path = new List<int>();

        bool[] visited = new bool[_vertextCount];

        InternalDFS(start, visited, path);

        return path;
    }

    public void InternalDFS(int current, bool[] visited, List<int> path)
    {
        visited[current] = true;
        path.Add(current);

        for(int to = 0; to <_vertextCount; to++)
        {
            if (matrix[current, to] && !visited[to])
            {
                InternalDFS(to, visited, path);
            }
        }
    }
}
```
# 길찾기
```csharp
using System;
using System.Collections.Generic;

class Program
{
    private static Tile[,] field = new Tile[20, 20];

    static void Main(string[] args)
    {
        Console.OutputEncoding = System.Text.Encoding.UTF8;
        Console.CursorVisible = false;

        InitField();

        for (int i = 0; i < 15; i++) field[10, i].State = TileState.Wall;

        Tile start = field[0, 0];
        Tile end = field[19, 19];

        PathFinder pathFinder = new PathFinder();

        if (pathFinder.BFS(field, start, end))
        {
            Console.Clear();
            PrintField();
            Console.SetCursorPosition(0, 21);
            Console.WriteLine("경로를 찾았습니다!");
        }
        else
        {
            PrintField();
            Console.SetCursorPosition(0, 21);
            Console.WriteLine("경로를 찾을 수 없습니다.");
        }
    }

    static void InitField()
    {
        for (int i = 0; i < field.GetLength(0); i++)
        {
            for(int j=0;j<field.GetLength(1);j++)
            {
                field[i, j] = new Tile(j, i);
            }
        }
    }

    static void SetWalls(params(int x, int y)[] points)
    {
        foreach((int x, int y) p in points)
        {
            field[p.y, p.x].State = TileState.Wall;
        }
    }

    static void PrintField()
    {
        for (int i = 0; i < field.GetLength(0); i++)
        {
            for (int j = 0; j < field.GetLength(1); j++)
            {
                field[i, j].Print();
            }
        }
    }
}

public class PathFinder
{
    private Point[] _directions =
    {
        Point.Up,
        Point.Down,
        Point.Left,
        Point.Right,
        Point.Up + Point.Left,
        Point.Up + Point.Right,
        Point.Down + Point.Left,
        Point.Down + Point.Right,
    };

    public bool BFS(Tile[,] field, Tile start, Tile end)
    {
        Queue<Tile> q = new Queue<Tile>();

        start.SetVisit(null);
        q.Enqueue(start);

        while(q.Count > 0)
        {
            Tile current = q.Dequeue();

            if (current == end)
            {
                BuildPath(start, end);
                return true;
            }
            // 주변 타일을 큐에 추가 + 방문처리
            foreach(Point dir in _directions)
            {
                Tile next;

                if (!TryGetNeighbor(field, current, dir, out next))
                {
                    continue;
                }

                if (next.IsBlocked)
                    continue;

                next.SetVisit(current);
                q.Enqueue(next);
            }
        }
        return false;
    }

    private bool TryGetNeighbor(Tile[,] field, Tile from, Point direction, out Tile neighbor)
    {
        neighbor = null;

        Point next = from.Position + direction;

        int rows = field.GetLength(0);
        int cols = field.GetLength(1);

        if(next.x <0 || cols <= next.x || next.y <0 || rows <= next.y)
        {
            return false;
        }

        neighbor = field[next.y, next.x];
        return neighbor != null;
    }

    private void BuildPath(Tile start, Tile end)
    {
        if (!end.HasPrevTile) return;

        Tile current = end;

        while(current != null)
        {
            if(current.State != TileState.Wall)
            {
                current.SetPath();
            }

            current = current.PrevTile;
        }
    }
}

public class Tile
{
    public TileState State { get; set; }
    public Point Position { get; set; }
    public Tile PrevTile { get; set; }

    public bool IsBlocked { get => State == TileState.Wall || State == TileState.Visited; }
    public bool HasPrevTile { get => PrevTile != null; }

    public Tile(int x, int y , TileState state = TileState.Normal )
    {
        Position = new Point(x, y);
        State = state;
    }

    public void SetVisit(Tile prev)
    {
        State = TileState.Visited;
        PrevTile = prev;
    }

    public void SetPath()
    {
        State = TileState.Path;
    }

    public void Print()
    {
        Console.SetCursorPosition(Position.x, Position.y);

        switch (State)
        {
            case TileState.Normal:
                PrintColor(ConsoleColor.Gray, '☐');
                break;
            case TileState.Wall:
                PrintColor(ConsoleColor.White, '■');
                break;
            case TileState.Visited:
                PrintColor(ConsoleColor.Yellow, '☐');
                break;
            case TileState.Path:
                PrintColor(ConsoleColor.Green, '■');
                break;
        }
    }

    private void PrintColor(ConsoleColor color, char symbol)
    {
        Console.ForegroundColor = color;
        Console.Write(symbol);
        Console.ResetColor();
    }

}

public struct Point
{
    public int x;
    public int y;

    public static Point Up    => new Point(+0, -1);
    public static Point Down  => new Point(+0, +1);
    public static Point Left  => new Point(-1, +0);
    public static Point Right => new Point(+1, +0);


    public Point(int x, int y)
    {
        this.x = x;
        this.y = y;
    }

    public static Point operator +(Point a, Point b)
    {
        return new Point(a.x + b.x, a.y + b.y);
    }

    public static Point operator -(Point a, Point b)
    {
        return new Point(a.x - b.x, a.y - b.y);
    }
}

public enum TileState
{
    Normal, Wall, Visited, Path
}
```