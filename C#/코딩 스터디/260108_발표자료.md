# 의존 역전 원칙 Dependency Inversion Principle

## 예시

1.소프트웨어가 아닌 하드웨어에서 먼저 설명한다.
하드웨어 예시
노트북과 마우스를 연결한다고 할때 usb단자라는 규격이 존재하지않을때는 노트북과 마우스를 연결하기 위해서는 전기신호선을 직접 연결해 사용해야 된다.
만약 마우스가 고장이 나거나 업그레이드를 하려고 하려면 마우스를 수정하기 위해 노트북에 어떤 수정이 가해져야 한다. 
하지만 usb단자라는 인터페이스를 통해 노트북과 마우스를 연결한다면 어떨까?
그냥 마우스만 수정해서 usb단자에만 맞다면 다시 넣으면 된다.

의존 역전 원칙은 이럴 경우 빛을 바란다.

# 또 다른 예시

여러 개의 전등이 있다. 하지만 전등의 스위치가 전등에 고정이 되어있다면 아주 피곤한 상황이 생길 수 있다.

## 예시 코드
```csharp
public interface ISwitchable
{
    void TurnOn();
    void TurnOff();
}

public class Switch
{
    private ISwitchable _device;
    public Switch(ISwitchable device) => _device = device;

    public void Operate(bool on)
    {
        if (on) _device.TurnOn();
        else _device.TurnOff();
    }
}
```

그렇다면 우리는 게임개발자가 되려니까 게임에서 예를 들어보자. 대표적으로 전사에게 칼을 쥐어준다 생각해보자 칼 종류만 하더라도 여러가지 종류가 있고 모든 칼을 전사에게 선언한다고 생각해보자

칼을 전사에게 선언하면 칼의 정보를 바꾸려면 전사에게 가서 정보를 바꿔야되는 상황이 되어 전사를 칼에 맞춰버리는상황이 있을수가있다. 이런 상황은 우리가 배웠던 객체지향의 원칙과 위배된다.

안쓴 예
```csharp
public class Sword {
    public void Swing()
    {
        Console.WriteLine("칼을 휘두른다.");
    }
}

public class Player {
    private Sword _weapon = new Sword(); // 강한 결합

    public void Attack() {
        _weapon.Swing(); // 무기가 바뀌면 이 코드도 바뀜
    }
}
```
적용한 예
```csharp
public interface IWeapon 
{
    void Use();
}

public class Sword : IWeapon 
{
    public void Use()
    {
        Console.WriteLine("칼을 휘두릅니다.");
    }
}

public class Bow : IWeapon 
{
    public void Use()
    {
        Console.WriteLine("화살을 쏩니다.");
    } 
}

public class Player
{
    private IWeapon _weapon;

    // 외부(인벤토리 시스템 등)에서 무기를 갈아 끼워줌 (주입)
    public void Equip(IWeapon weapon) {
        _weapon = weapon;
    }

    public void Attack() {
        _weapon?.Use(); // 어떤 무기인지 몰라도 Use만 호출하면 됨
    }
}
```

# 추상화의 핵심

추상화의 핵심은 무엇을 표시할것인지 무엇을 숨길것인지에 대한 것이다.

## 예시

핸드폰의 홈버튼을 누르면 홈으로 가는건 당연한데 어떤 전기적신호로 홈으로 가는지 사용자는 알 필요없음 
운전을 하는 운전자 입장에서 생각해보면 핸들, 엑셀, 브레이크만 알면됨 엔진이 어떤식으로 동작하는지 알 수는 있지만 필요는 없음