    # 자료구조 : List, LinkedList, Stack, Queue

    ## 1. List<T> (순차 자료구조)
    가장 많이 사용되는 동적 배열 형태의 자료구조이다.

    ### 특징
    - **순차적 메모리 할당**: 데이터가 메모리상에 연속적으로 배치됩니다.
    - **인덱스 접근**: `list[i]`와 같이 인덱스를 통해 데이터에 즉시 접근할 수 있습니다 ($O(1)$).
    - **데이터 삽입/삭제**: 
    - 맨 뒤에 추가/삭제할 때는 매우 빠릅니다 ($O(1)$).
    - 중간에 데이터를 넣거나 빼면 나머지 데이터를 밀거나 당겨야 하므로 느립니다 ($O(n)$).

    ### 핵심 코드
    ```csharp
    List<Monster> list = new List<Monster>();

    list.Add(new Monster("Oak"));         // 데이터 추가
    list.Insert(1, new Monster("Skull")); // 중간 삽입 (O(n))
    list.Remove(Slime);                   // 특정 객체 삭제
    list.RemoveAt(0);                     // 인덱스로 삭제
    list.Contains(Slime);                 // 데이터 존재 여부 확인
    ```
    ```csharp
    List<int> list = new List<int>();


    ```
    다음은 List를 활용한 코드 예시입니다.
    ```csharp
    using System;
    using System.Collections.Generic;

    class Program
    {
        static void Main(string[] args)
        {
            List<Monster> list = new List<Monster>();

            // 추가
            list.Add(new Monster("Oak"));
            Monster Slime = new Monster("Slime");
            list.Add(Slime);
            list.Add(new Monster("Goblin"));

            // 삽입
            list.Insert(1, new Monster("Skull"));

            static void PrintList(List<Monster> list)
            {
                foreach(Monster l in list)
                {
                    Console.Write($"{l.name}\t");
                }

                Console.WriteLine("");
            }

            // 탐색
            Console.WriteLine(list[2].name);

            if(list.Contains(Slime))
            {
                Console.WriteLine("슬라임 찾았음");
            }

            // 삭제
            list.Remove(Slime);

            list.RemoveAt(0);
        }
    }

    public class Monster
    {
        public string name { get; private set; }

            public Monster(string name)
        {
            this.name = name;
        }
    }
    ```
    ## 1. LinkedList<T> (연결 자료구조)
    데이터들 앞뒤로 서로의 주소를 가르키고 있는 자료구조이다.

    ### 특징
    - **유연한 삽입 삭제**: 노드 간의 연결만 바꾸면 되므로 삽입 삭제가 매우 빠르다.
    - **느린 탐**: 데이터를 찾기 위해서는 노드를 타고 가야된다. 
    - **인덱스로 탐색 불가**: 인덱스로 탐색할 수 없다.

    ### 핵심 코드
    ```csharp
    LinkedList<int> linkedList = new LinkedList<int>();

    LinkedListNode<int> node = linkedList.AddFirst(1); // 리스트의 첫번째에 추가한다.

    linkedList.AddLast(2);          // 리스트의 마지막에 추가한다.
    linkedList.AddBefore(node, 3);  // 지정노드의 전에 추가한다.
    linkedList.AddAfter(node, 4);   // 지정노드 후에 추가한다.
    linkedList.Remove(3);           // 지정 노드를 삭제한다.
    linkedList.RemoveFirst();       // 리스트의 첫번째를 삭제한다.
    linkedList.RemoveLast();        // 리스트의 마지막을 삭제한다.
    ```
    다음은 LinkedList를 활용한 코드 예시입니다.
    ```csharp
    using System;
    using System.Collections.Generic;

    class Program
    {
        static void Main(string[] args)
        {
            LinkedList<int> list = new LinkedList<int>();

            LinkedListNode<int> node = list.AddFirst(1);

            list.AddFirst(2); // [2][1]
            list.AddFirst(3); // [3][2][1]
            list.AddFirst(4); // [4][3][2][1]
            list.AddLast(5); // [4][3][2][1][5]

            list.AddBefore(node, 6); // [4][3][2][6][1][5]

            list.AddAfter(node, 7); //[4][3][2][6][1][7][5]

            list.Remove(7); // [4][3][2][6][1][5]

            list.RemoveFirst(); // [3][2][6][1][5]

            list.RemoveLast(); // [3][2][6][1]
    
            Console.WriteLine($"list Count : {list.Count}"); // 4
        }
    }
    ```
    ## Stack (LIFO : 선입후출)

    ### 특징
    - 한쪽 끝에서만 데이터를 넣고 뺄 수 있다.

    ### 핵심 코드
    ```csharp
    Stack<int> stack = new Stack<int>();

    stack.Push(); // 데이터를 쌓는다
    stack.Peek(); // 마지막 데이터를 확인한다
    stack.Pop();  // 데이터를 뺀다
    ```
    다음은 stack을 활용한 코드예시이다.
    ```csharp
    using System;
    using System.Collections.Generic;

    class Program
    {
        static void Main(string[] args)
        {
            Stack<int> stack = new Stack<int>();

            stack.Push(1);
            stack.Push(2);
            stack.Push(3);

            Console.WriteLine(stack.Peek()); // 확인만

            foreach (int i in stack)
            {
                Console.WriteLine(i);
            }

            Console.WriteLine($"value = {stack.Pop()} / count = {stack.Count}");
            Console.WriteLine($"value = {stack.Pop()} / count = {stack.Count}");
            Console.WriteLine($"value = {stack.Pop()} / count = {stack.Count}");
        }
    }

    public class Command
    {
        public int a;
    }
    ```
    ## Queue (FIFO : 선입선출)

    ### 특징 
    - 한쪽으로 데이터를 넣고 반대쪽으로 데이터를 빼는 구조입니다.

    ### 주요 함수
    ```csharp
    Queue<int> queue = new();

    queue.Enqueue(1); // 입구로 넣는 함수
    queue.Dequeue();  // 출구에서 빼는 함수
    ```
    다음코드는 queue를 활용한 코드예시입니다.
    ```csharp
    using System;
    using System.Collections.Generic;

    class Program
    {
        static void Main(string[] args)
        {
            Queue<Unit> Barracks = new();

            Barracks.Enqueue(new Unit("Marine"));
            Barracks.Enqueue(new Unit("Ghost"));
            Barracks.Enqueue(new Unit("Firebat"));
            Barracks.Enqueue(new Unit("Medic"));
            Barracks.Enqueue(new Unit("Marine"));


            Unit unit = Barracks.Dequeue();

            foreach(Unit u in Barracks)
            {
                Console.WriteLine($"{u.Name}\t");
            }
        }
    }

    public class Unit
    {
        public string Name { get; private set; }

        public Unit(string name)
        {
            Name = name;
        }
    }

    ```