# State Pattern(상태 패턴)

- 어떤 기능을 구현하려고 할 때 어떤 객체에다가 구체적인 기능구현을 하려고 하면 상태(State)가 늘어나게 되어 조건 분기의 수가 기하 급수 적으로 늘어나게 된다. 다음은 상태 패턴을 이용하지않은 좋지 않은 코드이다.

```csharp
void Update()
{
    HandleInput();
    ApplyGravity();
    CheckGround();

    if (_state == PlayerState.Idle)
    {
        ...
    }
    else if (_state == PlayerState.Move)
    {
        ...
    }
    else if (_state == PlayerState.Jump)
    {
        ...
        if (CanDoubleJump()) ...
        if (InputDash()) ...
        if (InputAttack()) ...
        if (IsHit()) ...
    }
    else if (_state == PlayerState.AirAttack)
    {
        ...
        if (ComboWindowOpen()) ...
        if (IsHit()) ...
        if (IsGrounded()) ...
    }
    else if (_state == PlayerState.Hit)
    {
        ...
        if (RecoverTimeOver()) ...
    }
    else if (_state == PlayerState.Die)
    {
        ...
    }
    // 계속 증가
}
```
상태에 따라 if문이 늘어나게 되어 상태가 엮이여 있어 가독성이 좋지 않고 책임이 한 객체에 몰리고 수정하기 아주 어려워진다.

## State Pattern 구조
| 요소 | 책임 | 하면 안 되는 것 |
| :--- | :--- | :--- |
| **Player** | 상태 실행 | 상태 로직 직접 구현 |
| **StateMachine** | 상태 교체 | 입력 처리 |
| **ConcreteState** | 자기 상태 행동 전달 | 다른 상태 내부 접근 |

## Unity에서 상태패턴을 가지는 임의의 객체 (Player)

### PlayerController.cs 틀 예시
```csharp
using UnityEngine;

// 입력 처리 / 물리 판정 / 애니메이션 결정
public class Player : MonoBehavoiur
{
	Rigidbody2D _rb;
	Animator _animator;
	
	StateMachine _stateMachine;
	
	// Player가 사용할 Stete들
	IdleState Idle;
	MoveState Move;
	JumpState Jump;
	
	void Start()
	{
		_stateMahcine = new StateMachine();
		Idle = new IdleState(this)
		Move = new MoveState(this);
		Jump = new JumpState(this);
		
		_stateMachine.ChangeState(Idle);
	}
	
	void Update()
	{
		_stateMachine.Update();
	}
	
	public void ChangeState(IState state)
	{
		_stateMachine.ChangeState(state);
	}
}
```